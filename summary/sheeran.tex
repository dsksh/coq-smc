\documentclass{jsarticle}
\usepackage[dvipdfmx]{graphicx}

\usepackage{url}
\usepackage{color,listings,lstcoq}
\usepackage{amsmath,amssymb, amsthm, plistings} % 数学用
\usepackage{here}
\usepackage{mathptmx}
\usepackage{setspace} 
\usepackage{dirtree}
\usepackage{bm}
\usepackage{ulem}


\lstset{basicstyle= {\ttfamily}, escapechar=\@, numbers= none, xleftmargin= 5pt} %lisntingsの設定

\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.1,0.6}
\definecolor{dkgreen}{rgb}{0,0.5,0}
\definecolor{dkviolet}{rgb}{1.0,0,0}
\definecolor{dkred}{rgb}{0.5,0,0}


\begin{document}

\section{Sheeranらの方法1}
\begin{multline}
    \Bigl(~(\neg \exists s_{[0..k]}. \  I(s_0) \land \mathit{loopFree}(s_{[0..k]})) \ \lor \
    (\neg\exists s_{[0..k]}. \ \mathit{loopFree}(s_{[0..k]})  \ \lor\ \neg P(s_k))~\Bigr) ~~   \land \\ %\nonumber \\
  　\bigwedge_{0 \leq i \leq k} \bigl(\neg\exists s_{[0..i]}. \ I(s_0) \ \land \ \mathit{path}(s_{[0..i]})\ \land \ \neg P(s_i)\bigr) 
  　\label{eq:Sheeran1} %Sheeran
\end{multline}


\subsection{証明の概要}
\label{s:proof-summary}

ここでは, Sheeranらの方法1の健全性を証明する.
つぎに, システム安全であるとき以下の条件式が成り立つ.
\begin{align}
 \label{eq:safety2} %
 \forall i. \ \forall s_{[0..i]}. \ \neg(I(s_0) \ \wedge \ \mathit{path}(s_{[0..i]}) \ \wedge \neg P(s_i))
\end{align}
さらに, 小さい$i$から順に検査していく場合, 閉路を含む実行パスの到達する先はすでに検証済みであることを考慮に入れると 
式\eqref{eq:safety2}は以下の式と等価と言える.
\begin{align}
 \label{eq:safety3} %
  \forall i. \ \forall s_{[0...i]}. \ \neg (I(s_0)  \wedge \mathit{loopFree}(s_{[0..k]}) \ \wedge \neg P(s_i))
\end{align}
この式は, 初期状態$s_0$から性質$P$を満たさない状態$s_i$に到達するような閉路を含まない実行パスは, 存在しないことを表す.
従って, 「式\eqref{eq:Sheeran1}ならば, 式\eqref{eq:safety3}が成り立つ」を証明すれば, Sheeranらの方法1の健全性を示せたことになる.

以下, 証明の流れを述べる.
まず, $i < k$と$i \geq k$に場合分けを行い, それぞれ 
\begin{align}
 \label{eq:sub-safety3}
  \forall s_{[0..i]}. \ \neg (I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..i]}) \ \wedge \ \neg P(s_i)) 
\end{align}
が成り立つことを証明する.

$i < k$の場合, 式\eqref{eq:Sheeran1}の3行目より, 
$k$ステップ目まで安全であることが分かっているので, 式\eqref{eq:sub-safety3}が成り立つ. 

つぎに, $i \geq k$の場合について証明する.
式\eqref{eq:Sheeran1}より, (a) $\forall s_{[0..k]}. \ \neg(I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..k]}))$ 
(b) $\forall s_{[0..k]}. \ \neg (\mathit{loopFree}(s_{[0..k]}) \ \wedge \ \neg P(s_k))$のどちらかが成り立つことがわかっている.
ここで, 閉路を含まない実行パス$\mathit{loopFree}(s_{[0..i]})$は分割できることを利用すると, 
式\eqref{eq:safety3}の部分式 $I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..i]})\ \wedge \ \neg P(s_i)$は以下のように書くことができる.
\begin{align}
 \label{eq:divide1}
  I(s_0) \  \wedge \ \mathit{loopFree}(s_{[0..k]}) \ \wedge \ \mathit{loopFree}(s_{[k..i]}) \ \wedge \ \neg P(s_i)
 \end{align}
式\eqref{eq:divide1}は, (a)が成り立つとき否定されるので, 式\eqref{eq:sub-safety3}が成り立つ.
また, $I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..i]})\ \wedge \ \neg P(s_i)$は, 以下のように分割することもできる.
\begin{align}
 \label{eq:divide2}
  I(s_0) \  \wedge \ \mathit{loopFree}(s_{[0..(i-k)]}) \ \wedge \ \mathit{loopFree}(s_{[(i-k)..i]}) \ \wedge \neg \ P(s_i)
 \end{align}
 そして, $i \geq k$の場合, (b)は以下のように考えて良い.
 \begin{align}
 \label{eq:shift-state}
 \Bigl(\forall s_{[0..k]}. \ \neg (\mathit{loopFree}(s_{[0..k]}) \ \wedge \ \neg P(s_k))\Bigr) \ \Leftrightarrow \
 \Bigl(\forall s_{[(i-k)..i]}. \ \neg (\mathit{loopFree}(s_{[(i-k)..i]}) \ \wedge \ \neg P(s_i))\Bigr)
 \end{align}
(b)が成り立つときは, 式\eqref{eq:divide2}が否定されるので, 式\eqref{eq:sub-safety3}が成り立つ.
よって, $i \leq k$の場合も, 式\eqref{eq:sub-safety3}が成り立つ.


以上により, すべての$i$について式\eqref{eq:sub-safety3}が成り立つので, Sheeranらのエンコード方法1の健全性が示された.

\subsection{Coq上での証明}

\dirtree{%
.1 \color{red}{Threorem} \color{blue}{Proof\_Sheeran\_method1}. 
.2 \color{red}{Lemma} \color{blue}{Proof\_Sheeran\_method1\_case1}.
.3 \color{red}{Lemma} \color{blue}{case1\_t1}.
.4 \color{red}{Lemma} \color{blue}{lt\_big\_and\_incl}. 
.2 \color{red}{Lemma} \color{blue}{Proof\_Sheeran\_method1\_case2}.
.3 \color{red}{Lemma} \color{blue}{divide\_loop\_free}.
.4 \color{red}{Lemma} \color{blue}{divide\_path}.
.5 \color{red}{Lemma} \color{blue}{shift\_path}.
.6 \color{red}{Lemma} \color{blue}{divide\_tl\_path}.
.6 \color{red}{Lemma} \color{blue}{divide\_hd\_path}.
.4 \color{red}{Lemma} \color{blue}{divide\_no\_loop}.
.5 \color{red}{Lemma} \color{blue}{divide\_no\_loop1}.
.5 \color{red}{Lemma} \color{blue}{divide\_no\_loop2}.
.6 \color{red}{Lemma} \color{blue}{divide\_no\_loop2'}.
.7 \color{red}{Lemma} \color{blue}{divide\_no\_loop2''}.
.3 \color{red}{Lemma} \color{blue}{case2\_t1} \color{red}{(Admitted!)}.
}\


※下に証明の概要を書く. \\

\begin{lstlisting}[language = Coq, frame=tb, framesep=5pt, breaklines = true] % path

Theorem Proof_Sheeran_method1 :
  forall (k : nat) (I : init) (T : trans) (P : property) (l : list nat),
     Sheeran_method1 I T P l k  ->  (forall (i : nat) (s : ss), ~ (I (s 0) /\ loop_free T s 0 i l /\ ~ P (s i))).
Proof.
  intros.
  assert (H0 : i < k \/ i >= k).
  omega.
  destruct H0.
  - revert H0.   (* i < k ->   ~ (I (s 0) /\ loop_free T s 0 i l /\ ~ P (s i))). *)
    apply Proof_Sheeran_method1_case1. 
    tauto.   
  - revert H0.   (* i >= k ->   ~ (I (s 0) /\ loop_free T s 0 i l /\ ~ P (s i))). *)
    apply  Proof_Sheeran_method1_case2.
    tauto.
Qed.
\end{lstlisting}

\newpage

まず, \texttt{Proof\_Sheeran\_method1\_case1}を証明する.

\begin{lstlisting}[language = Coq, frame=tb, framesep=5pt, breaklines = true] % path

Lemma case1_t1 : forall  (i k : nat) (s : ss) (I : init) (T : trans) (P : property),
  (i < k)  /\  kth_P_safe I T P k  ->   ~ (I (s 0)  /\  path T s 0 i  /\  ~ P (s i)).

Theorem Proof_Sheeran_method1_case1 :
  forall (k : nat) (I : init) (T : trans) (P : property) (l : list nat),
    Sheeran_method1 I T P l k
    -> (forall (i : nat) (s : ss),  (i < k)%nat  -> ~ (I (s 0) /\ loop_free T s 0 i l /\ ~ P (s i))).
Proof.
  unfold Sheeran_method1.
  intros.
  assert((i < k) /\ kth_P_safe I T P k).
  tauto.
  apply case1_t1 with (s := s) in H1.  
  unfold loop_free.
  tauto.
Qed.
\end{lstlisting}
\texttt{case1\_t1}を\texttt{apply}するために, \texttt{assert}を使って,式変形を行っているだけ.
\texttt{kth\_P\_safe}は, 式\eqref{eq:Sheeran1}の2行目の部分を表している.\\

次に, \texttt{Proof\_Sheeran\_method1\_case2}を証明する.
\begin{lstlisting}[language = Coq,  frame=tb, framesep=5pt, breaklines = true] % path

Lemma case2_t1 : forall  (i k : nat) (T : trans) (P : property) (l : list nat),
  (i >= k)%nat ->
  (forall s1 : ss, ~ (loop_free T s1 (i-k) k l /\ ~ P (s1 i))) <->  
  (forall s2 : ss, ~ (loop_free T s2 0 k l /\ ~ P (s2 k))).
 Proof. Admitted. 
 
Theorem divide_loop_free : forall  (i j: nat) (s : ss) (T : trans) (l : list nat),
  loop_free T s 0 (i+j) l  ->   loop_free T s 0 i l  /\  loop_free T s i j l.
  
Theorem Proof_Sheeran_method1_case2 :
  forall  (k : nat) (I : init) (T : trans) (P : property) (l : list nat),
    Sheeran_method1 I T P l k   ->   
    (forall (i : nat) (s : ss), (i >= k)%nat  ->  ~ (I (s 0) /\ loop_free T s 0 i l /\ ~ P (s i))).
 Proof.
  unfold Sheeran_method1.
  intros.
  apply neg_false.   (*結論部分を I (s 0) /\ loop_free T s 0 i l /\ ~ P (s i)) <-> False に変形*)
  split. (* -> と <- に分ける. *)
  - intros.
    destruct H.
    destruct H.
    + assert (H3 : i =  k + (i - k)). omega.
      unfold lasso in H.
      destruct H1.
      destruct H4.
      rewrite H3 in H4.
      apply divide_loop_free in H4. 
      firstorder.
    + unfold violate_loop_free in H.
      simpl in H.
      destruct H1.
      destruct H3.
      assert (H5 : i = i - k + k). omega.
      rewrite H5 in H3.   
      apply divide_loop_free in H3.
      apply (case2_t1 i k T P l) in H0.
      rewrite <- H0 in H.
      firstorder.
  - tauto.
Qed.        
\end{lstlisting}
\texttt{case2\_t1}と\texttt{divide\_loop\_free}を使用して, 証明した. 
この証明は, 前節の $k \leq i$の場合の証明と同じ流れで証明している. 
\texttt{case2\_t1}は, まだ未証明. 

\newpage

以下, 使用した補題一覧. 

\begin{lstlisting}[language = Coq,  frame=tb, framesep=5pt, breaklines = true] % path
 
 Lemma divide_path : forall  (i j: nat) (s : ss) (T : trans),
  path T s 0 (i+j)  ->   path T s 0 i  /\  path T s i j.
 
 Lemma divide_loop_check : forall  (i j: nat) (s : ss) (l : list nat),
  loop_check s 0 (i+j) l  ->   loop_check s 0 i l  /\  loop_check s i j l.
 
 Lemma divide_loop_free : forall  (i j: nat) (s : ss) (T : trans) (l : list nat),
   loop_free T s 0 (i+j) l  ->   loop_free T s 0 i l  /\  loop_free T s i j l.
  
 Lemma divide_tl_path : forall  (i : nat) (s : ss) (T : trans),
   path T s 0 (S i)  <->   path T s 0 i  /\  T (s i) (s (S i)).

 Lemma divide_hd_path : forall  (i j : nat) (s : ss) (T : trans),
   T (s i) (s (S i)) /\  path T s (S i) j  <->   path T s i (S j).

 Lemma shift_path : forall  (i j : nat) (s : ss) (T : trans), 
   path T s 0 i  /\  path T s i (S j) <->  path T s 0 (S i)  /\  path T s (S i) j .

 Lemma divide_path : forall  (i j: nat) (s : ss) (T : trans),
   path T s 0 (i+j)  ->   path T s 0 i  /\  path T s i j.

Lemma divide_lc1 : forall  (j i : nat) (s : ss) (l : list nat), 
  loop_check s 0 (i+j) l  ->   loop_check s 0 i l.

Lemma divide_lc2'' : forall  (i j k : nat) (s : ss) (l : list nat),
  loop_check' s i (S k) (S j) l <->
  neq_nth_mth (s (i + (S k))) (s i) l 0 /\  loop_check' s (S i) k j l.

Lemma divide_lc2' : forall  (j i : nat) (s : ss) (l : list nat),
  loop_check s i (S j) l  ->   loop_check s (S i) j l.

Lemma divide_lc2 : forall  (i j : nat) (s : ss) (l : list nat),
  loop_check s 0 (i+j) l  ->   loop_check s i j l.

Lemma divide_loop_check : forall  (i j: nat) (s : ss) (l : list nat),
  loop_check s 0 (i+j) l  ->   loop_check s 0 i l  /\  loop_check s i j l.

Lemma lt_big_and_incl : forall (i k : nat) (P : nat -> Prop),
    i < k /\ big_and P 0 (S k) -> big_and P 0 (S i).
\end{lstlisting}


\section{Sheeranらの方法2}
$k$-inductionとして知られる検査法.
\begin{multline}
    \Bigl(~(\neg \exists s_{[0..k]}. \  I(s_0) \land \mathit{loopFree}(s_{[0..k]})) \ \lor \
    (\neg\exists s_{[0..k]}. \ \mathit{loopFree}(s_{[0..k]}) \ \lor \ \mathit{all.} P(s_{[0..(k-1)]}) \ \lor\ \neg P(s_k))~\Bigr) ~~  \land \\ %\nonumber \\
  　\bigwedge_{0 \leq i \leq k} \bigl(\neg\exists s_{[0..i]}. \ I(s_0) \ \land \ \mathit{path}(s_{[0..i]})\ \land \ \neg P(s_i)\bigr) 
  　\label{eq:Sheeran2} %Sheeran
\end{multline}

\subsection{証明の概要}

以下, 証明の流れを述べる.
まず, $i < k$と$i \geq k$に場合分けを行い, それぞれ 
\begin{align}
 \label{eq:sub-safety3}
  \forall s_{[0..i]}. \ \neg (I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..i]}) \ \wedge \neg \ P(s_i)) 
\end{align}
が成り立つことを証明する.

$i < k$の場合, 式\eqref{eq:Sheeran2}の2行目より, 
$k$ステップ目まで安全であることが分かっているので, 式\eqref{eq:sub-safety3}が成り立つ. 

つぎに, $i \geq k$の場合について証明する.
式\eqref{eq:Sheeran1}より, 
\begin{itemize}
 \item[(a)] $\forall s_{[0..k]}. \ \neg(I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..k]}))$ 
 \item[(b)] $\forall s_{[0..k]}. \ \neg (\mathit{loopFree}(s_{[0..k]}) \land \ \mathit{all.} P(s_{[0..(k-1)]}) \ \wedge \ \neg P(s_k))$
\end{itemize}
のどちらかが成り立つことがわかっている.
(a) が成り立つ場合の証明は, 方法1のときと同じなのでここでは省略し,  (b)が成り立つ場合についての証明のみを行う.

(b) が成り立つ場合の証明には, 完全帰納法 (complete induction)を使用して証明する.
完全帰納法とは, 以下の式が妥当であることをいう.
\begin{align}
 \label{eq:comp-ind}
 \Bigl (~ \forall i. \Bigl ( \forall m. m < i \to P(m) \Bigr) \to P(i) ~\Bigr)\ \to \ \forall i. P(i)
 \end{align}
 
$k = 0$は, 

次に, $k \geq 1$に対しての証明を行う.
式\eqref{eq:sub-safety3}を以下のように変形する.
\begin{align}
 \label{eq:sub-safety4}
  \forall s_{[0..i]}. \ I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..i]}) \ \to \ P(s_i)
\end{align}
そして, $P(s_i)$の部分に式\eqref{eq:comp-ind}を適用して整理すると, 仮定は以下のようになる.
\begin{align}
  \forall s_{[0..i]}. \ I(s_0) \ \wedge \ \mathit{loopFree}(s_{[0..i]}) \label{eq:1}\\
  \forall s_{[0..k]}. \ \mathit{loopFree}(s_{[0..k]}) \land \ \mathit{all.} P(s_{[0..(k-1)]}) \ \to \ P(s_k) \label{eq:2} \\
  \forall m. \ \forall s_m. \ m < i \ \to \ P(s_m) \label{eq:3}
\end{align}
上の3つの式から, $P(s_i)$ を導出できればよい.
上の式を以下のように変形する. ($i - k \geq 0$) 
\begin{align}
  \forall s_{[0..i]}. \ I(s_0) \ \land \ \mathit{loopFree}(s_{[0..(i-k)]}) \ \land \ \mathit{loopFree}(s_{[(i-k)..i]}) \label{eq:4}\\
  \forall s_{[(i-k)..i]}. \ \mathit{loopFree}(s_{[(i-k)..i}) \land \ \mathit{all.} P(s_{[(i-k)..(i-1)]}) \ \to \ P(s_i) \label{eq:5} \\
  \forall m. \ \forall s_{[0..m]}. \ m < i \ \to \ I(s_0) \ \land \ \mathit{loopFree}(s_{[0..(i-m)]}) \ \to \ P(s_m) \label{eq:6}
\end{align}
式\eqref{eq:5}から, $P(s_i)$を$\mathit{loopFree}(s_{[(i-k)..i}) \land \ \mathit{all.} P(s_{[(i-k)..(i-1)]})$に変形できる.
これは, $\mathit{loopFree}(s_{[(i-k)..i}) \land \ P(s_{(i-k)}) \ \land \ P(s_{(i-k+1)}) \ \land \ .. \ \land \ P(s_{(i-1)})$であるので, 式\eqref{eq:4}, 式\eqref{eq:6} から成り立つ.
よって. (b) が成り立つとき場合も, 式\eqref{eq:safety3}は成り立つ.









\end{document}
